# Docs for the Azure Web Apps Deploy action: https://github.com/Azure/webapps-deploy
# More GitHub Actions for Azure: https://github.com/Azure/actions

name: Shared Blackball - Publish to Azure

on:
 workflow_call:
    inputs:
     project_to_deploy:
      required: true
      type: string
     azure_app_name:
      required: true
      type: string
     working_directory:
      required: false
      type: string
      default: ./
    secrets:
      azure_publish_profile:
        required: true

jobs:

  publish:
    runs-on: windows-latest
    

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0  # We need this to get the full commit history, which is used below to get the last commit date for each file in App/Web
      - name: Bump version
        shell: pwsh
        run: |
            Get-ChildItem -Path .\ -Filter *.csproj -Recurse -File | ForEach-Object {
                $assemblyInfoPath = $_.FullName
                $folderName = $_.Directory

                # If we have a UI project, I want to grab the lastest modified file date, because our front-end raises 'update' notifications
                # based on this. I am hard-coding our convention-based names (App and Web) here, so this will need updating later if we do something else
                if ($_.Name -eq "App.csproj" -or $_.Name -eq "Web.csproj") {
            
                    # Define your filter more cleanly using an array and -in operator
                    $validExtensions = @(".cs", ".css", ".js", ".less", ".cshtml")
                
                    # Get all files in the folder and its subfolders that match your criteria
                    $filesToInspect = Get-ChildItem $folderName -Recurse -File | Where-Object {
                        $_.Extension -in $validExtensions -and
                        $_.Name -notlike "*.runtimeconfig.json" -and
                        $_.Name -notlike "*.nuget.dgspec.json" -and
                        $_.Name -notlike "*appsettings.json" -and
                        $_.FullName -notlike "*\bin\*" -and
                        $_.FullName -notlike "*\obj\*" -and
                        $_.FullName -notlike "*\.vscode\*"
                    }
                
                    $lastModifiedFile = $null
                    $lastModified = [datetime]::MinValue
                
                    # Loop through each filtered file to find the one with the latest commit date
                    foreach ($file in $filesToInspect) {
                        # Use git log to get the author date of the last commit for this file
                        # The -1 option gets only the last commit
                        # --pretty=format:%ad formats the output to just the author date
                        # -- $file.FullName ensures that git correctly handles the file path
                        # Use the call operator '&' and parentheses to ensure the command and its arguments are processed correctly
                        # The extra quotes around the file name are crucial for paths with spaces
                        # Create a parameter list for git log to ensure arguments are passed correctly
                        $gitLogParams = @(
                            'log',
                            '-1',
                            '--pretty=format:%ad',
                            '--date=iso',
                            '--',
                            $file.FullName
                        )
                        
                        # Use the call operator '&' to execute the command with the parameter list
                        $gitDateString = & git @gitLogParams
                        
                        # Check if a date was returned (files not in git history will return nothing)
                        if ($gitDateString) {
                            # Convert the string output from git log into a DateTime object
                            $commitDate = [datetime]::ParseExact($gitDateString, 'yyyy-MM-dd HH:mm:ss zzz', [System.Globalization.CultureInfo]::InvariantCulture)

                            if ($commitDate -gt $lastModified) {
                                $lastModified = $commitDate
                                $lastModifiedFile = $file
                            }
                        }
                    }
                    # Set lastModified ($lastModifiedFile).LastWriteTime
                    "The last modified file for $($_.Name) was $($lastModifiedFile.Name), at $lastModified (from git commit date)"
                }else{
                    # For all other projects, we can just use the current date - save us trawling through the git history
                    Get-Date | Set lastModified
                }

                # Patch the csproj file version 
                $packageVersion = $lastModified.ToString("3.yy.MMdd.HHmm")
                Set versionTag "<FileVersion>$packageVersion</FileVersion>"
                ((Get-Content -path $assemblyInfoPath -Raw) -replace '\<FileVersion\>[^\<]+\</FileVersion\>', $versionTag) | Set-Content -path $assemblyInfoPath
            }
            
            "Bumping service worker version $packageVersion"
            Get-Date -Format "3.yy.MMdd.HHmm" | Set packageVersion
            Set versionTag "<FileVersion>$packageVersion</FileVersion>"
            Set swTag "const VERSION = ""$packageVersion"";"
            Get-ChildItem -Path .\ -Filter serviceworker.* -Recurse -File -Name| ForEach-Object {
             Set swFilePath $_
             "Patching $swFilePath"
             ((Get-Content -path $swFilePath -Raw) -replace 'const VERSION = \"[^\"]+\";', $swTag) | Set formattedFile
             Set-Content $formattedFile -path $swFilePath
            }

      - name: Set up .NET Core
        uses: actions/setup-dotnet@v2
        with:
          dotnet-version: '9.0.x'
          include-prerelease: true

          
      - name: Initialize Blackball Nuget Farm
        run: dotnet nuget add source --name blackball "https://nuget.blackballsoftware.com/api/v2"
      
      - name: Publish
        working-directory: ${{inputs.working_directory}}
        # 23 May 2022, Ben Liebert: If I add --no-build and --no-restore flags to this line, it fails to generate the assets.json file and cannot publish. Which is weird
        # because by this point we have already built/restored (in other workflow) and I thought that adding these flags was entirely the point of pre-building?
        run: dotnet publish ${{inputs.project_to_deploy}}\${{inputs.project_to_deploy}}.csproj -c Release -o ${{env.DOTNET_ROOT}}/${{inputs.project_to_deploy}} -a x64
       
      - name: Upload Web artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: .net-app-${{inputs.project_to_deploy}}
          path: ${{env.DOTNET_ROOT}}/${{inputs.project_to_deploy}}


  deploy:
    runs-on: windows-latest
    needs: publish
    environment:
      name: 'staging'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}

    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: .net-app-${{inputs.project_to_deploy}}

      - name: Deploy to Azure
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{inputs.azure_app_name}}
          slot-name: staging
          publish-profile: ${{ secrets.azure_publish_profile }}
          package: .
